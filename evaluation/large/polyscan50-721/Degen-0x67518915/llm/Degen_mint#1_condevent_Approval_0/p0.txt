Given a solidity function mint and the related parts from a smart contract.
Whether it explicitly contains the given action? Reply in "YES" or "NO".



Function(and related parts) to audit:"""
pragma solidity 0.8.10;
library Counters {

    function current(Counter storage counter) internal view returns (uint256) {
        return counter._value;

    }
    function increment(Counter storage counter) internal {
        unchecked {
            counter._value += 1;
        }
    }
}

contract Degen is ERC721, Ownable {
    Counters.Counter private _tokenIdCounter;
    // Mapping to track which wallets have minted each token

    mapping(uint256 => mapping(address => bool)) private _tokenMinters;
    // The fee for minting an NFT
    uint256 public mintFee = 0.5 ether; // 0.5 Matic

    // The address to receive the minting fee
    address payable public feeRecipient = payable(0x8D018A345B3e244D402B37039dcA241b99ee8d1B);
    function mint(address to, uint256 baseTokenId) public payable {
        // Check that the correct fee has been paid
        require(msg.value >= mintFee, "Insufficient fee");

        // Check that the wallet has not already minted this token
        require(!_tokenMinters[baseTokenId][to], "Token has already been minted by this wallet");

        // Mint the NFT
        _tokenIdCounter.increment();
        uint256 newTokenId = baseTokenId * 10**12 + _tokenIdCounter.current();
        _mint(to, newTokenId);

        // Mark this token as having been minted by this wallet
        _tokenMinters[baseTokenId][to] = true;

        // Send the fee to the fee recipient
        feeRecipient.transfer(mintFee);

        // Refund any excess fee
        if (msg.value > mintFee) {
            payable(msg.sender).transfer(msg.value - mintFee);
        }
    }
}
contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {

    // Mapping from token ID to owner address
    mapping(uint256 => address) private _owners;

    // Mapping owner address to token count
    mapping(address => uint256) private _balances;

    /**
     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist
     */
    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {
        return _owners[tokenId];
    }

    /**
     * @dev Returns whether `tokenId` exists.
     *
     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
     *
     * Tokens start existing when they are minted (`_mint`),
     * and stop existing when they are burned (`_burn`).
     */
    function _exists(uint256 tokenId) internal view virtual returns (bool) {
        return _ownerOf(tokenId) != address(0);
    }

    /**
     * @dev Mints `tokenId` and transfers it to `to`.
     *
     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible
     *
     * Requirements:
     *
     * - `tokenId` must not exist.
     * - `to` cannot be the zero address.
     *
     * Emits a {Transfer} event.
     */
    function _mint(address to, uint256 tokenId) internal virtual {
        require(to != address(0), "ERC721: mint to the zero address");
        require(!_exists(tokenId), "ERC721: token already minted");

        _beforeTokenTransfer(address(0), to, tokenId, 1);

        // Check that tokenId was not minted by `_beforeTokenTransfer` hook
        require(!_exists(tokenId), "ERC721: token already minted");

        unchecked {
            // Will not overflow unless all 2**256 token ids are minted to the same owner.
            // Given that tokens are minted one by one, it is impossible in practice that
            // this ever happens. Might change if we allow batch minting.
            // The ERC fails to describe this case.
            _balances[to] += 1;
        }

        _owners[tokenId] = to;

        emit Transfer(address(0), to, tokenId);

        _afterTokenTransfer(address(0), to, tokenId, 1);
    }

    /**
     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is
     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.
     *
     * Calling conditions:
     *
     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.
     * - When `from` is zero, the tokens will be minted for `to`.
     * - When `to` is zero, ``from``'s tokens will be burned.
     * - `from` and `to` are never both zero.
     * - `batchSize` is non-zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */

    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}
    /**
     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is
     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.
     *
     * Calling conditions:
     *
     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.
     * - When `from` is zero, the tokens were minted for `to`.
     * - When `to` is zero, ``from``'s tokens were burned.
     * - `from` and `to` are never both zero.
     * - `batchSize` is non-zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}
}
"""

Action:"""
when the approved address for an NFT is changed or reaffirmed
"""
